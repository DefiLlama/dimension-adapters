import { FetchOptions, SimpleAdapter } from "../../adapters/types";
import { CHAIN } from "../../helpers/chains";

const RAIN_PROTOCOL_FACTORY = "0xccCB3C03D9355B01883779EF15C1Be09cf3623F1";
const RAIN_PROTOCOL_USDT = "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9"; // USDT token address on Arbitrum

const PlatformFeeClaimEvent = "event PlatformClaim(address indexed wallet, uint256 amount)"; // USDT burnt as fees
const CreatorFeeClaimEvent = "event CreatorClaim(address indexed wallet, uint256 amount)"; // USDT paid to pool creators
const ReferrerFeeClaimEvent = "event RefererClaim(address indexed wallet, uint256 amount)"; // USDT paid to referer
const ResolverFeeClaimEvent = "event ResolverClaim(address indexed wallet, uint256 amount)"; // USDT paid to resolver
const ClaimEvent = "event Claim(address indexed wallet, uint256 winnerOption, uint256 liquidityReward, uint256 reward, uint256 totalReward)"; // USDT claimed by users (also includes pool liquidity incentive rewards)
const PoolCreatedEvent = "event PoolCreated(address indexed poolAddress, address indexed poolCreator, string uri)";

const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances(); // overall fees of each pool from protocol
  const dailyRevenue = options.createBalances(); // revenue generated by the protocol from platformFees

  const pools: any[] = await options.getLogs({
    target: RAIN_PROTOCOL_FACTORY,
    eventAbi: PoolCreatedEvent,
  });
  const poolAddresses = pools.map((log) => log.poolAddress);
  const batchSize = 100;

  for (let i = 0; i < poolAddresses.length; i += batchSize) {
    const batch = poolAddresses.slice(i, i + batchSize);

    const platformFeeLogs: any[] = await options.getLogs({ targets: batch, eventAbi: PlatformFeeClaimEvent });
    const creatorFeeLogs: any[] = await options.getLogs({ targets: batch, eventAbi: CreatorFeeClaimEvent });
    const referrerFeeLogs: any[] = await options.getLogs({ targets: batch, eventAbi: ReferrerFeeClaimEvent });
    const resolverFeeLogs: any[] = await options.getLogs({ targets: batch, eventAbi: ResolverFeeClaimEvent });
    const claimLogs: any[] = await options.getLogs({ targets: batch, eventAbi: ClaimEvent });

    for (const feeLog of platformFeeLogs) {
      dailyFees.add(RAIN_PROTOCOL_USDT, feeLog.amount);
      dailyRevenue.add(RAIN_PROTOCOL_USDT, feeLog.amount);
    }
    for (const feeLog of creatorFeeLogs) {
      dailyFees.add(RAIN_PROTOCOL_USDT, feeLog.amount);
    }
    for (const feeLog of referrerFeeLogs) {
      dailyFees.add(RAIN_PROTOCOL_USDT, feeLog.amount);
    }
    for (const feeLog of resolverFeeLogs) {
      dailyFees.add(RAIN_PROTOCOL_USDT, feeLog.amount);
    }
    for (const claimLog of claimLogs) {
      dailyFees.add(RAIN_PROTOCOL_USDT, claimLog.liquidityReward);
    }
  }
  return { dailyFees, dailyUserFees: dailyFees, dailyRevenue, dailyHoldersRevenue: dailyRevenue };
};

const methodology = {
  Fees: 'All fees paid by users for each pool in USDT via Rain Protocol Markets.',
  Revenue: 'Platform Fees are used to buy back and burn RAIN Token.',
  ProtocolRevenue: 'Protocol doesnt earn any revenue.',
  HoldersRevenue: 'Platform Fees are used to buy back and burn RAIN Token.',
}

const adapter: SimpleAdapter = {
  version: 2,
  fetch,
  chains: [CHAIN.ARBITRUM],
  start: "2025-02-17",
  methodology
}

export default adapter;