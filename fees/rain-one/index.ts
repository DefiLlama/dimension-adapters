import { FetchOptions, SimpleAdapter } from "../../adapters/types";
import { CHAIN } from "../../helpers/chains";

const PlatformFeeClaimEvent = "event PlatformClaim(address indexed wallet, uint256 amount)"; // USDT burnt as fees
const CreatorFeeClaimEvent = "event CreatorClaim(address indexed wallet, uint256 amount)"; // USDT paid to pool creators
const ReferrerFeeClaimEvent = "event RefererClaim(address indexed wallet, uint256 amount)"; // USDT paid to referer
const ResolverFeeClaimEvent = "event ResolverClaim(address indexed wallet, uint256 amount)"; // USDT paid to resolver
const ClaimEvent = "event Claim(address indexed wallet, uint256 winnerOption, uint256 amount, uint256 reward, uint256 totalReward)"; // USDT claimed by users (also includes pool liquidity incentive rewards)
const poolTokenSetEvent =
  "event PoolTokenSet(address indexed poolAddress,address indexed tokenAddress,uint256 tokenDecimals,string tokenName,string tokenSymbol)";

const rainFactory = "0xccCB3C03D9355B01883779EF15C1Be09cf3623F1";
const poolCreatedEvent =
  "event PoolCreated(address indexed poolAddress, address indexed poolCreator, string uri)";
const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances(); // overall fees of each pool from protocol
  const dailyRevenue = options.createBalances(); // revenue generated by the protocol from platformFees


  const poolCreationLogs = await options.getLogs({
    target: rainFactory,
    eventAbi: poolCreatedEvent,
    fromBlock: 307026817,
    cacheInCloud: true,
  });

  const pools = poolCreationLogs.map((log) => log.poolAddress);

  const poolsEndTime = await options.api.multiCall({ abi: "uint256:endTime", calls: pools, });

  const filteredPools = pools.filter((_, i) => poolsEndTime[i] >= options.fromTimestamp,);

  const poolTokenSetLogs = await options.getLogs({
    target: rainFactory,
    eventAbi: poolTokenSetEvent,
    fromBlock: 307026817,
    cacheInCloud: true,
  });

  const poolTokenMap: Record<string, { token: string; decimals: number }> = {};

  poolTokenSetLogs.forEach((log) => {
    poolTokenMap[log.poolAddress.toLowerCase()] = {
      token: log.tokenAddress.toLowerCase(),
      decimals: Number(log.tokenDecimals),
    };
  });

  const addLogFees = (logs: any[]) => {
    if (!logs || logs.length === 0) return;
    logs.forEach((log: any) => {
      const pool = log.address.toLowerCase();
      const tokenInfo = poolTokenMap[pool]
      if (!tokenInfo?.token) throw new Error(`Token info not found for pool ${pool}`);
      dailyFees.add(tokenInfo.token, log.args.amount);
    })
  }

  await processLogs({
    options, pools, eventAbi: PlatformFeeClaimEvent, processor: async (logs: any) => {
      if (!logs || logs.length === 0) return;
      logs.forEach((log: any) => {
        const pool = log.address.toLowerCase();
        const tokenInfo = poolTokenMap[pool]
        if (!tokenInfo?.token) throw new Error(`Token info not found for pool ${pool}`);
        dailyFees.add(tokenInfo.token, log.args.amount);
        dailyRevenue.add(tokenInfo.token, log.args.amount);
      })
    }
  })

  await processLogs({ options, pools, eventAbi: CreatorFeeClaimEvent, processor: addLogFees })
  await processLogs({ options, pools, eventAbi: ReferrerFeeClaimEvent, processor: addLogFees })
  await processLogs({ options, pools, eventAbi: ResolverFeeClaimEvent, processor: addLogFees })
  // await processLogs({ options, pools, eventAbi: ClaimEvent, processor: addLogFees })

  return { dailyFees, dailyUserFees: dailyFees, dailyRevenue, dailyHoldersRevenue: dailyRevenue };


  async function processLogs({ eventAbi, processor }: { options: FetchOptions, pools: string[], eventAbi: string, processor: (logs: any[]) => void }) {

    return options.streamLogs({
      noTarget: true,
      eventAbi,
      entireLog: true,
      targetsFilter: filteredPools,
      processor,
    })
  }

};

const methodology = {
  Fees: 'All fees paid by users for each pool in USDT via Rain Protocol Markets.',
  Revenue: 'Platform Fees are used to buy back and burn RAIN Token.',
  ProtocolRevenue: 'Protocol doesnt earn any revenue.',
  HoldersRevenue: 'Platform Fees are used to buy back and burn RAIN Token.',
}

const adapter: SimpleAdapter = {
  version: 2,
  fetch,
  chains: [CHAIN.ARBITRUM],
  start: "2025-02-17",
  methodology,
  pullHourly: true,
}

export default adapter;