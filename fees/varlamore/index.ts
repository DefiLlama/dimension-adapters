import { CHAIN } from '../../helpers/chains'
import { FetchOptions, FetchResultV2, SimpleAdapter } from '../../adapters/types'
import { getERC4626VaultsInfo } from '../../helpers/erc4626'
import { METRIC } from '../../helpers/metrics'

/**
 * Varlamore Capital - DeFi yield aggregator operating managed vaults on Silo Finance V2
 * https://varlamore.capital/
 *
 * Vaults are ERC4626-compatible and charge performance fees on yields generated
 */

// Silo V2 managed vault fee ABI
const feeAbi = 'uint256:fee'

// Varlamore vault addresses
const VAULTS: Record<string, string[]> = {
  [CHAIN.ETHEREUM]: [
    '0xa9b23B28621CFB32e0ebf50b572aFAC671fCc17B', // Varlamore Falcon USDC
    '0xAD43BD27A4D7C18C05f78F24D9BD3fA6805C2ff6', // Varlamore ETH
  ],
  [CHAIN.SONIC]: [
    '0xDED4aC8645619334186f28B8798e07ca354CFa0e', // Varlamore S
  ],
}

async function fetch(options: FetchOptions): Promise<FetchResultV2> {
  const dailyFees = options.createBalances()
  const dailyRevenue = options.createBalances()

  const vaultAddresses = VAULTS[options.chain] || []

  // Use ERC4626 helper to get vault info at start and end of period
  const [vaultInfosBefore, vaultInfosAfter] = await Promise.all([
    getERC4626VaultsInfo(options.fromApi, vaultAddresses),
    getERC4626VaultsInfo(options.toApi, vaultAddresses),
  ])

  // Read fee from contract (WAD format: 1e18 = 100%)
  const fees = await options.api.multiCall({
    abi: feeAbi,
    calls: vaultAddresses,
    permitFailure: true,
  })

  for (let i = 0; i < vaultAddresses.length; i++) {
    const vaultKey = vaultAddresses[i].toLowerCase()
    const infoBefore = vaultInfosBefore[vaultKey]
    const infoAfter = vaultInfosAfter[vaultKey]
    const feeRate = fees[i] ? BigInt(fees[i]) : 0n

    // Skip if missing required data
    if (!infoBefore || !infoAfter) {
      continue
    }

    // Calculate yield from exchange rate growth (assetsPerShare)
    const rateGrowth = infoAfter.assetsPerShare - infoBefore.assetsPerShare
    if (rateGrowth <= 0n) {
      continue
    }

    // Total yield calculation:
    // assetsPerShare is assets per 1e18 vault shares (from convertToAssets(1e18))
    // totalShares â‰ˆ totalAssets * 1e18 / assetsPerShare
    // yield = rateGrowth * totalShares / 1e18 = rateGrowth * totalAssets / assetsPerShare
    const yieldGenerated = (rateGrowth * infoAfter.totalAssets) / infoAfter.assetsPerShare

    // Calculate performance fee from yield
    const performanceFee = (yieldGenerated * feeRate) / BigInt(1e18)

    // Add to balances
    dailyFees.add(infoAfter.asset, yieldGenerated, METRIC.ASSETS_YIELDS)
    dailyRevenue.add(infoAfter.asset, performanceFee, METRIC.PERFORMANCE_FEES)
  }

  // Supply side revenue = total fees - protocol revenue
  const dailySupplySideRevenue = dailyFees.clone(1)
  dailySupplySideRevenue.subtract(dailyRevenue)

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue: dailyRevenue,
    dailySupplySideRevenue,
  }
}

const methodology = {
  Fees: 'Total yield generated by Varlamore managed vaults through Silo Finance lending markets.',
  Revenue: 'Performance fees collected by Varlamore.',
  ProtocolRevenue: 'All performance fees go to Varlamore protocol.',
  SupplySideRevenue: 'Yield distributed to vault depositors after performance fees.',
}

const breakdownMethodology = {
  Fees: {
    [METRIC.ASSETS_YIELDS]: 'Yield generated from Silo Finance lending markets.',
  },
  Revenue: {
    [METRIC.PERFORMANCE_FEES]: 'Performance fees charged on vault yields.',
  },
  ProtocolRevenue: {
    [METRIC.PERFORMANCE_FEES]: 'Performance fees retained by Varlamore.',
  },
  SupplySideRevenue: {
    [METRIC.ASSETS_YIELDS]: 'Yield distributed to vault depositors.',
  },
}

const adapter: SimpleAdapter = {
  version: 2,
  adapter: {
    [CHAIN.SONIC]: {
      fetch,
      start: '2025-04-24', // Sonic vault deployed
    },
    [CHAIN.ETHEREUM]: {
      fetch,
      start: '2025-06-25', // USDC vault deployed
    },
  },
  methodology,
  breakdownMethodology,
}

export default adapter
