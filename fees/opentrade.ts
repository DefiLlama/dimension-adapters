import { FetchOptions, SimpleAdapter } from "../adapters/types";
import { CHAIN } from "../helpers/chains";
import ADDRESSES from "../helpers/coreAssets.json";

/**
 * OpenTrade - Tokenized Money Market Fund & Bond Vaults
 *
 * Fee Structure (from docs):
 * - Advisor Fee: 0.10% - covers advising OpenTrade SPC on portfolio management
 * - Platform Fee: 0.20% - covers development and maintenance of the platform
 * - Liquidity Fee: 0.20% - covers providing liquidity for immediate interest payments
 * - Total: 0.50% per annum, deducted from gross yield
 *
 */

const TOTAL_FEE_BPS = 50n; // 0.50% = 50 bps
const BPS_DENOMINATOR = 10000n;

// Underlying assets per chain
const USDC: Record<string, string> = {
  [CHAIN.AVAX]: ADDRESSES.avax.USDC,
  [CHAIN.ETHEREUM]: ADDRESSES.ethereum.USDC,
  [CHAIN.PLUME]: "0x3938A812c54304fEffD266C7E2E70B48F9475aD6", // USDC on Plume
};

const EURC: Record<string, string> = {
  [CHAIN.AVAX]: "0xC891EB4cbdEFf6e073e859e987815Ed1505c2ACD", // EURC on Avalanche
  [CHAIN.ETHEREUM]: "0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c", // EURC on Ethereum
};

const USDT: Record<string, string> = {
  [CHAIN.ETHEREUM]: ADDRESSES.ethereum.USDT,
};

interface VaultConfig {
  address: string;
  asset: string;
  name: string;
}

const config: Record<string, VaultConfig[]> = {
  [CHAIN.AVAX]: [
    {
      address: "0x09Ca60Ca323a6313aE144778c3EbDfCCFBB5e5D2", //04/14/2025
      asset: USDC[CHAIN.AVAX],
      name: "XMMF",
    },
    {
      address: "0x061329361E0f163125225bf71a1E5AF954b46869", //04/07/2025
      asset: USDC[CHAIN.AVAX],
      name: "XFTB",
    },
    {
      address: "0xad6605F4987031fd2d6d6816bE53Eb7C5b764bf7", //09/02/2024
      asset: USDC[CHAIN.AVAX],
      name: "XTBT",
    },
    {
      address: "0xBFdEf5e389bB403426337081eCD1D05bC5193203", //02/04/2025
      asset: EURC[CHAIN.AVAX],
      name: "XEVT",
    },
    {
      address: "0x1D7E71d0CB499C31349DF3E9205A4b16bcCF2536", //03/31/2025
      asset: USDC[CHAIN.AVAX],
      name: "XHYC",
    },
  ],
  [CHAIN.ETHEREUM]: [
    {
      address: "0x0f8CbdC544dC1D4Bd1bDafE0039Be07B825aF82A", //02/29/2024
      asset: USDC[CHAIN.ETHEREUM],
      name: "XTBT",
    },
    {
      address: "0x3Ee320c9F73a84D1717557af00695A34b26d1F1d", //04/25/2024
      asset: EURC[CHAIN.ETHEREUM],
      name: "XEVT",
    },
    {
      address: "0x1e571c87556F216662fa8D25143b1b0618512Ef6", //05/09/2025
      asset: USDC[CHAIN.ETHEREUM],
      name: "XMMF",
    },
    {
      address: "0xD06f235DF80D4981816F7fB0936973155CDe1f4C", //05/15/2025
      asset: USDT[CHAIN.ETHEREUM],
      name: "XMMF-USDT",
    },
  ],
  [CHAIN.PLUME]: [
    {
      address: "0x6688aA2eB549e325C21a16c942827C9c99F40dd9", //05/15/2025
      asset: USDC[CHAIN.PLUME],
      name: "XMMF",
    },
    {
      address: "0xf19d819F23b05C231C0de1dde97289476A0Bcf30", //06/12/2025
      asset: USDC[CHAIN.PLUME],
      name: "XHYCB",
    },
  ],
};

const abis = {
  exchangeRate: "uint256:exchangeRate",
  totalSupply: "uint256:totalSupply",
};

const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances();
  const dailyRevenue = options.createBalances();
  const dailySupplySideRevenue = options.createBalances();

  const vaults = config[options.chain];
  const vaultAddresses = vaults.map((v) => v.address);

  const [totalSupplies, ratesBefore, ratesAfter] = await Promise.all([
    options.api.multiCall({
      abi: abis.totalSupply,
      calls: vaultAddresses,
      permitFailure: true,
    }),
    options.fromApi.multiCall({
      abi: abis.exchangeRate,
      calls: vaultAddresses,
      permitFailure: true,
    }),
    options.toApi.multiCall({
      abi: abis.exchangeRate,
      calls: vaultAddresses,
      permitFailure: true,
    }),
  ]);

  for (let i = 0; i < vaults.length; i++) {
    const vault = vaults[i];
    const supply = totalSupplies[i];
    const rateBefore = ratesBefore[i];
    const rateAfter = ratesAfter[i];

    if (!supply || !rateBefore || !rateAfter) {
      continue;
    }

    const rateDelta = BigInt(rateAfter) - BigInt(rateBefore);

    if (rateDelta <= 0n) {
      continue;
    }

    const netYield = (rateDelta * BigInt(supply)) / BigInt(1e18);

    const grossYield =
      (netYield * BPS_DENOMINATOR) / (BPS_DENOMINATOR - TOTAL_FEE_BPS);

    const protocolFee = grossYield - netYield;

    dailyFees.add(vault.asset, grossYield);
    dailyRevenue.add(vault.asset, protocolFee);
    dailySupplySideRevenue.add(vault.asset, netYield);
  }

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue: dailyRevenue,
    dailySupplySideRevenue,
  };
};

const methodology = {
  Fees: "Total gross yield generated by vaults (net yield + protocol fees).",
  Revenue:
    "Protocol fees (0.50% of gross yield): Advisor 0.10% + Platform 0.20% + Liquidity 0.20%.",
  ProtocolRevenue: "Same as Revenue - fees collected by OpenTrade protocol.",
  SupplySideRevenue:
    "Net yield distributed to vault depositors after protocol fees.",
};

const adapter: SimpleAdapter = {
  version: 2,
  adapter: {
    [CHAIN.AVAX]: {
      fetch,
      start: "2024-09-02",
    },
    [CHAIN.ETHEREUM]: {
      fetch,
      start: "2024-02-29",
    },
    [CHAIN.PLUME]: {
      fetch,
      start: "2025-05-15",
    },
  },
  methodology,
};

export default adapter;
