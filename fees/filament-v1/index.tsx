import BigNumber from "bignumber.js";
import request, { gql } from "graphql-request";
import { FetchOptions, SimpleAdapter } from "../../adapters/types";
import { CHAIN } from "../../helpers/chains";

const endpoint =
  "https://api.goldsky.com/api/public/project_cm0qvthsz96sp01utcnk55ib0/subgraphs/filament-sei/v3/gn";

// Get timestamps for yesterday and today
const now = Math.floor(Date.now() / 1000); // Current timestamp in seconds
const yesterday = now - 86400; // 24 hours ago

// Basic query without where clauses
const queryAllFees = gql`
  query AllFees {
    totalTradingFees(first: 1000, orderBy: timestamp_, orderDirection: desc) {
      id
      timestamp_
      block_number
      account
      totalFees
    }
  }
`;

// Query with skip parameter for pagination
const queryFeesWithSkip = gql`
  query AllFeesWithSkip($skip: Int!) {
    totalTradingFees(
      first: 1000
      skip: $skip
      orderBy: timestamp_
      orderDirection: desc
    ) {
      id
      timestamp_
      block_number
      account
      totalFees
    }
  }
`;

interface IFeeEntry {
  id: string;
  timestamp_: string;
  block_number: string;
  account: string;
  totalFees: string;
}

interface IFeesResponse {
  totalTradingFees: Array<IFeeEntry>;
}

const methodology = {
  totalFees:
    "Tracks the cumulative fees (borrowing fees + trading fees) generated by all transactions.",
  dailyFees:
    "Tracks the fees (borrowing fees + trading fees) generated by transactions on a daily basis.",
};

const toString = (x: BigNumber) => {
  if (x.isEqualTo(0)) return undefined;
  return x.toString();
};

/**
 * Fetches all fee entries with proper pagination
 */
const fetchAllFeeEntries = async (maxPages = 10): Promise<IFeeEntry[]> => {
  let allEntries: IFeeEntry[] = [];
  let currentSkip = 0;
  let hasMoreData = true;
  let pageCount = 0;

  console.log("Starting fee data collection with pagination");

  while (hasMoreData && pageCount < maxPages) {
    pageCount++;

    try {
      console.log(`Fetching page ${pageCount} with skip=${currentSkip}`);

      const response: IFeesResponse = await request(
        endpoint,
        pageCount === 1 ? queryAllFees : queryFeesWithSkip,
        pageCount === 1 ? {} : { skip: currentSkip }
      );

      const { totalTradingFees } = response;
      const entriesCount = totalTradingFees.length;

      console.log(`Received ${entriesCount} entries on page ${pageCount}`);

      allEntries = [...allEntries, ...totalTradingFees];

      // If we got fewer than 1000 entries, we've reached the end
      if (entriesCount < 1000) {
        hasMoreData = false;
        console.log("Reached the end of the data");
      } else {
        currentSkip += 1000;
      }
    } catch (error) {
      console.error(`Error fetching page ${pageCount}:`, error);
      hasMoreData = false; // Stop on error
    }
  }

  if (pageCount >= maxPages) {
    console.log(
      `Reached maximum page limit (${maxPages}). There may be more data.`
    );
  }

  console.log(`Total entries collected: ${allEntries.length}`);
  return allEntries;
};

const fetchProtocolFees = async () => {
  try {
    console.log("Now", now);
    console.log("Yesterday", yesterday);

    // Fetch all available fee entries (with pagination)
    const allEntries = await fetchAllFeeEntries(50); // Set max pages to 50 (up to 50,000 entries)

    // Calculate daily and total fees
    let dailyFees = new BigNumber(0);
    let totalFees = new BigNumber(0);
    let dailyEntryCount = 0;

    // Process each fee entry
    allEntries.forEach((entry) => {
      const entryTimestamp = parseInt(entry.timestamp_);
      const feesAmount = new BigNumber(entry.totalFees);

      // Add to total fees
      totalFees = totalFees.plus(feesAmount);

      // Check if entry is from the last 24 hours
      if (entryTimestamp >= yesterday && entryTimestamp <= now) {
        dailyFees = dailyFees.plus(feesAmount);
        dailyEntryCount++;

        // Log a few daily entries for debugging
        if (dailyEntryCount <= 3) {
          console.log(
            `Sample daily entry: time=${new Date(
              entryTimestamp * 1000
            ).toISOString()}, amount=${entry.totalFees}`
          );
        }
      }
    });

    console.log(`Found ${dailyEntryCount} entries for daily fees calculation`);
    console.log("Daily Fees Raw", toString(dailyFees));
    console.log("Total Fees Raw", toString(totalFees));

    // Safety check: ensure total fees are at least equal to daily fees
    if (dailyFees.isGreaterThan(totalFees)) {
      console.error(
        "Error: Total fees are less than daily fees. This is logically impossible."
      );
      console.log(
        "Setting total fees to at least daily fees to maintain data consistency"
      );
      totalFees = dailyFees;
    }

    // Normalize by dividing by 10^18
    const normalizedDailyFees = dailyFees.dividedBy(new BigNumber(1e18));
    const normalizedTotalFees = totalFees.dividedBy(new BigNumber(1e18));

    const _dailyFees = toString(normalizedDailyFees);
    const _totalFees = toString(normalizedTotalFees);

    console.log(`SEI ðŸ‘‡`);
    console.log(`Backfill start time: 21/1/2023`);
    console.log(`Daily fees: ${_dailyFees}`);
    console.log(`Total fees: ${_totalFees}`);

    return {
      dailyFees: _dailyFees ?? "0",
      totalFees: _totalFees ?? "0",
    };
  } catch (error) {
    console.error("Error fetching protocol fees:", error);
    return {
      dailyFees: "0",
      totalFees: "0",
    };
  }
};

const adapter: SimpleAdapter = {
  adapter: {
    [CHAIN.SEI]: {
      fetch: fetchProtocolFees,
      start: "2023-01-21",
      meta: {
        methodology,
      },
    },
  },
};

export default adapter;
