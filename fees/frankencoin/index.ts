import { FetchOptions, SimpleAdapter } from '../../adapters/types';
import { CHAIN } from '../../helpers/chains';
import { request, gql } from 'graphql-request';

// GraphQL endpoint for Frankencoin
const FRANKENCOIN_GRAPH_URL = 'https://ponder.frankencoin.com';

// ZCHF token address on Ethereum
const ZCHF_ADDRESS = '0xB58E61C3098d85632Df34EecfB899A1Ed80921cB';

// query type
type RevenueQuery = {
	chainId: number;
	count: number;
	created: number;
	kind: string;
	amount: bigint;
	profits: bigint;
	losses: bigint;
};

// fetch function
const fetch = async (options: FetchOptions) => {
	const dailyFees = options.createBalances();
	const dailyRevenue = options.createBalances();

	const PROFIT_LOSS_QUERY = gql`
    query {
      frankencoinProfitLosss(
        where: {
          chainId: 1,
          created_gt: "${options.startTimestamp}",
          created_lte: "${options.endTimestamp}",
        }
        orderBy: "count",
        orderDirection: "desc",
        limit: 1000,
      ) {
        items {
          created
          kind
          amount
        }
      }
    }
  `;

	try {
		const { frankencoinProfitLosss } = await request(
			FRANKENCOIN_GRAPH_URL,
			PROFIT_LOSS_QUERY
		);

		const entries: RevenueQuery[] = frankencoinProfitLosss.items;

		const profits = entries.filter((e) => e.kind == 'Profit');
		const losses = entries.filter((e) => e.kind == 'Loss');

		// accumulate
		const accumProfits = profits.reduce((a, b) => {
			return a + BigInt(b.amount);
		}, 0n);

		const accumLosses = losses.reduce((a, b) => {
			return a + BigInt(b.amount);
		}, 0n);

		// Fees are the total profits in ZCHF
		dailyFees.add(ZCHF_ADDRESS, accumLosses);

		// Revenue is profits minus losses in ZCHF
		const revenue = accumProfits - accumLosses;
		dailyRevenue.add(ZCHF_ADDRESS, revenue > 0n ? revenue : 0n);

		return {
			dailyFees,
			dailyRevenue,
			dailyProtocolRevenue: dailyRevenue,
		};
	} catch (error) {
		console.error('Error fetching Frankencoin data:', error);
		return {
			dailyFees,
			dailyRevenue,
			dailyProtocolRevenue: dailyRevenue,
		};
	}
};

const adapter: SimpleAdapter = {
	version: 2,
	adapter: {
		[CHAIN.ETHEREUM]: {
			fetch,
			start: '2023-10-28',
			meta: {
				methodology: {
					Fees: 'Total profits generated by the Frankencoin protocol in ZCHF tokens',
					Revenue:
						'Net revenue calculated as profits minus losses in ZCHF tokens',
					ProtocolRevenue:
						'All net revenue is retained by the protocol in ZCHF tokens',
				},
			},
		},
	},
};

export default adapter;
