import { Interface } from "ethers"
import { Adapter, FetchOptions, FetchResultV2 } from "../../adapters/types"
import { CHAIN } from "../../helpers/chains"
import * as sdk from '@defillama/sdk'

/**
 * Lombard DeFi Vault (LBTCv)
 * 
 * Lombard DeFi Vault is an automated yield management solution designed to maximize BTC-denominated returns
 * by strategically allocating deposits across various opportunities within the DeFi ecosystem.
 * 
 * The vault accepts LBTC, wBTC, eBTC and cbBTC deposits and issues LBTCv tokens.
 * 
 * Fees:
 * - Performance fees: a percentage amount of yield
 * - Platform fees: a basic percentage amount of total assets in the vault
 */

const methodology = {
  Fees: 'Total yields are generated by staking assets in DeFi strategies (Aave, Pendle, Uniswap, etc).',
  SupplySideRevenue: 'The amount of yields distributed to LBTCv stakers.',
  Revenue: 'The amount of yields distributed to Lombard Protocol.',
  ProtocolRevenue: 'The amount of yields distributed to Lombard Protocol.',
}

interface IBoringVault {
  vault: string;
  accountantAbiVersion: 1 | 2;
}

const BoringVaults: {[key: string]: Array<IBoringVault>} = {
  [CHAIN.ETHEREUM]: [
    {
      vault: '0x5401b8620E5FB570064CA9114fd1e135fd77D57c',
      accountantAbiVersion: 2,
    },
  ]
}

const BoringVaultAbis = {
  //vault
  hook: 'address:hook',
  decimals: 'uint8:decimals',
  totalSupply: 'uint256:totalSupply',
  
  // hook
  accountant: 'address:accountant',
  
  // accountant
  base: 'address:base',
  exchangeRateUpdated: 'event ExchangeRateUpdated(uint96 oldRate, uint96 newRate, uint64 currentTime)',
  accountantState: {
    1: 'function accountantState() view returns(address,uint128,uint128,uint96,uint16,uint16,uint64,bool,uint32,uint16)',
    2: 'function accountantState() view returns(address,uint96,uint128,uint128,uint96,uint16,uint16,uint64,bool,uint24,uint16,uint16)',
  },
}

const AccountantFeeRateBase = 1e4

interface ExchangeRateUpdatedEvent {
  blockNumber: number;
  oldRate: bigint;
  newRate: bigint;
}

async function fetch(options: FetchOptions): Promise<FetchResultV2> {
  const dailyFees = options.createBalances()
  const dailySupplySideRevenue = options.createBalances()
  const dailyProtocolRevenue = options.createBalances()

  const vaults = BoringVaults[options.chain]

  if (vaults && vaults.length > 0) {
    const vault = vaults[0]
    
    const hook = await options.api.call({
      abi: BoringVaultAbis.hook,
      target: vault.vault,
    })
    const decimals = await options.api.call({
      abi: BoringVaultAbis.decimals,
      target: vault.vault,
    })
    const accountant = await options.api.call({
      abi: BoringVaultAbis.accountant,
      target: hook,
    })
    const token = await options.api.call({
      abi: BoringVaultAbis.base,
      target: accountant,
    })
    
    const vaultRateBase = Number(10 ** Number(decimals))

      // get vaults rate updated events
      const poolContract: Interface = new Interface([
        BoringVaultAbis.exchangeRateUpdated,
      ])
      const events: Array<ExchangeRateUpdatedEvent> = (await options.getLogs({
        eventAbi: BoringVaultAbis.exchangeRateUpdated,
        entireLog: true,
        target: accountant,
      }))
      .map(log => {
        const decodeLog: any = poolContract.parseLog(log)

        const event: any = {
          blockNumber: Number(log.blockNumber),
          oldRate: decodeLog.args[0],
          newRate: decodeLog.args[1],
        }

        return event
      })

      for (const event of events) {
        // newRate - oldRate
        const growthRate = event.newRate > event.oldRate ? Number(event.newRate - event.oldRate) : 0

        if (growthRate > 0) {
          
          // get total staked in vault at the given block
          // it's safe for performance because ExchangeRateUpdated events
          // occur daily once
          const totalSupplyAtUpdated = await sdk.api2.abi.call({
            abi: BoringVaultAbis.totalSupply,
            target: vault.vault,
            block: event.blockNumber,
          })
          const getAccountantState = await sdk.api2.abi.call({
            abi: BoringVaultAbis.accountantState[vault.accountantAbiVersion],
            target: accountant,
            block: event.blockNumber,
          })

          let exchangeRate = vaultRateBase
          let performanceFeeRate = 0
          if (vault.accountantAbiVersion === 2) {
            exchangeRate = Number(getAccountantState[4])
            // only version 2 vaults have performance fee config
            performanceFeeRate = Number(getAccountantState[11]) / AccountantFeeRateBase
          } else {
            exchangeRate = Number(getAccountantState[3])
          }
          
          // rate is always greater than or equal 1
          const totalDeposited = Number(totalSupplyAtUpdated) * Number(exchangeRate) / vaultRateBase

          const supplySideYield = totalDeposited * growthRate / vaultRateBase
          const totalYield = supplySideYield / (1 - performanceFeeRate)
          const protocolFee = totalYield - supplySideYield

          dailyFees.add(token, totalYield)
          dailySupplySideRevenue.add(token, supplySideYield)
          dailyProtocolRevenue.add(token, protocolFee)
        }
      }

      // get total asset are deposited in vault
      const totalSupply = await options.api.call({
        abi: BoringVaultAbis.totalSupply,
        target: vault.vault,
      })
      const getAccountantState = await options.api.call({
        abi: BoringVaultAbis.accountantState[vault.accountantAbiVersion],
        target: accountant,
      })

      const exchangeRate = vault.accountantAbiVersion === 1 ? Number(getAccountantState[3]) : Number(getAccountantState[4])
      const platformFeeRate = vault.accountantAbiVersion === 1 ? Number(getAccountantState[9]) : Number(getAccountantState[10])

      const totalDeposited = Number(totalSupply) * Number(exchangeRate) / vaultRateBase

      // platform fees charged per year of total assets in vault
      // 365 * 24 * 60 * 60 = seconds in a year (used to convert annual fee rate to time period)
      const yearInSecs = 365 * 24 * 60 * 60
      const timespan = options.toApi.timestamp && options.fromApi.timestamp ? Number(options.toApi.timestamp) - Number(options.fromApi.timestamp) : 86400
      const platformFee = totalDeposited * (platformFeeRate / AccountantFeeRateBase) * timespan / yearInSecs

    dailyFees.add(token, platformFee)
    dailyProtocolRevenue.add(token, platformFee)
  }

  return {
    dailyFees,
    dailyRevenue: dailyProtocolRevenue,
    dailySupplySideRevenue,
    dailyProtocolRevenue,
  }
}

const adapter: Adapter = {
  version: 2,
  methodology,
  adapter: {
    [CHAIN.ETHEREUM]: {
      fetch: fetch,
      start: '2024-07-22',
    },
  }
}

export default adapter
