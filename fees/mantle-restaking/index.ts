import { Interface } from "ethers"
import { Adapter, FetchOptions, FetchResultV2 } from "../../adapters/types"
import { CHAIN } from "../../helpers/chains"
import { METRIC } from "../../helpers/metrics"
import * as sdk from '@defillama/sdk'

const cmETH = '0xE6829d9a7eE3040e1276Fa75293Bde931859e8fA';
const accountant = '0x6049Bd892F14669a4466e46981ecEd75D610a2eC';

const methodology = {
  Fees: 'Total yields are generated by staking assets in DeFi strategies',
  SupplySideRevenue: 'The amount of yields distributed to cmETH stakers.',
  Revenue: 'Performance fees and platform fees distributed to Mantle Protocol.',
  ProtocolRevenue: 'Performance fees and platform fees distributed to Mantle Protocol.',
}

const breakdownMethodology = {
  Fees: {
    [METRIC.ASSETS_YIELDS]: 'Total yield generated by the vault strategy.',
    [METRIC.PERFORMANCE_FEES]: 'Performance fees collected by Mantle protocol on vault yield.',
    [METRIC.MANAGEMENT_FEES]: 'Fees collected by Mantle protocol as platform fees.',
  },
  Revenue: {
    [METRIC.PERFORMANCE_FEES]: 'Performance fees collected by Mantle protocol on vault yield.',
    [METRIC.MANAGEMENT_FEES]: 'Platform fee portion collected by protocol.',
  },
  SupplySideRevenue: {
    [METRIC.ASSETS_YIELDS]: 'Yield portion distributed to cmETH stakers.',
  },
}

const BoringVaultAbis = {
  //vault
  totalSupply: 'uint256:totalSupply',

  // accountant
  base: 'address:base',
  decimals: 'uint8:decimals',
  exchangeRateUpdated: 'event ExchangeRateUpdated(uint96 oldRate, uint96 newRate, uint64 currentTime)',
  accountantState: 'function accountantState() view returns(address,uint96,uint128,uint128,uint96,uint16,uint16,uint64,bool,uint24,uint16,uint16)',
}

const AccountantFeeRateBase = 1e4

interface ExchangeRateUpdatedEvent {
  blockNumber: number;
  oldRate: bigint;
  newRate: bigint;
}

async function fetch(options: FetchOptions): Promise<FetchResultV2> {
  const dailyFees = options.createBalances()
  const dailySupplySideRevenue = options.createBalances()
  const dailyProtocolRevenue = options.createBalances()

  const token = await options.api.call({
    abi: BoringVaultAbis.base,
    target: accountant,
  })

  const decimals = await options.api.call({
    abi: BoringVaultAbis.decimals,
    target: accountant,
  })

  const vaultRateBase = Number(10 ** Number(decimals))

  // get vaults rate updated events
  const poolContract: Interface = new Interface([
    BoringVaultAbis.exchangeRateUpdated,
  ])
  const events: Array<ExchangeRateUpdatedEvent> = (await options.getLogs({
    eventAbi: BoringVaultAbis.exchangeRateUpdated,
    entireLog: true,
    target: accountant,
  }))
    .map(log => {
      const decodeLog: any = poolContract.parseLog(log)
      console.log('decodeLog', decodeLog)

      const event: any = {
        blockNumber: Number(log.blockNumber),
        oldRate: decodeLog.args[0],
        newRate: decodeLog.args[1],
      }

      return event
    })
    .sort((a, b) => a.blockNumber - b.blockNumber)

  if (events.length > 0) {
    const firstEvent = events[0]
    const lastEvent = events[events.length - 1]

    // Calculate growth rate from start to end of period
    const startRate = firstEvent.oldRate
    const endRate = lastEvent.newRate
    const growthRate = Number(endRate - startRate)

    // Check if vault is paused - ignore paused vaults in yield calculation
    const getAccountantState = await sdk.api2.abi.call({
      abi: BoringVaultAbis.accountantState,
      target: accountant,
      block: firstEvent.blockNumber,
    })
    const isPaused = getAccountantState[8]

    if (!isPaused) {
      const totalSupplyAtUpdated = await sdk.api2.abi.call({
        abi: BoringVaultAbis.totalSupply,
        target: cmETH,
        block: firstEvent.blockNumber,
      })

      const exchangeRate = Number(getAccountantState[4])
      // version 2 vaults have performance fee config at index [11]
      const performanceFeeRate = Number(getAccountantState[11]) / AccountantFeeRateBase

      // rate is always greater than or equal 1
      const totalDeposited = Number(totalSupplyAtUpdated) * Number(exchangeRate) / vaultRateBase

      const supplySideYield = totalDeposited * growthRate / vaultRateBase
      const totalYield = supplySideYield / (1 - performanceFeeRate)
      const protocolFee = totalYield - supplySideYield

      dailyFees.add(token, supplySideYield, METRIC.ASSETS_YIELDS)
      dailyFees.add(token, protocolFee, METRIC.PERFORMANCE_FEES)
      dailySupplySideRevenue.add(token, supplySideYield, METRIC.ASSETS_YIELDS)
      dailyProtocolRevenue.add(token, protocolFee, METRIC.PERFORMANCE_FEES)
    }
  }

  // get total asset are deposited in vault
  const totalSupply = await options.api.call({
    abi: BoringVaultAbis.totalSupply,
    target: cmETH,
  })

  const getAccountantState = await options.api.call({
    abi: BoringVaultAbis.accountantState,
    target: accountant,
  })

  const exchangeRate = Number(getAccountantState[4])
  const platformFeeRate = Number(getAccountantState[10])

  const totalDeposited = Number(totalSupply) * Number(exchangeRate) / vaultRateBase

  // platform fees charged per year of total assets in vault
  // 365 * 24 * 60 * 60 = seconds in a year (used to convert annual fee rate to time period)
  const yearInSecs = 365 * 24 * 60 * 60
  const timespan = options.toApi.timestamp && options.fromApi.timestamp ? Number(options.toApi.timestamp) - Number(options.fromApi.timestamp) : 86400
  const platformFee = totalDeposited * (platformFeeRate / AccountantFeeRateBase) * timespan / yearInSecs

  dailyFees.add(token, platformFee, METRIC.MANAGEMENT_FEES)
  dailyProtocolRevenue.add(token, platformFee, METRIC.MANAGEMENT_FEES)

  return {
    dailyFees,
    dailyRevenue: dailyProtocolRevenue,
    dailyProtocolRevenue,
    dailySupplySideRevenue,
  }
}

const adapter: Adapter = {
  version: 2,
  fetch,
  chains: [CHAIN.ETHEREUM],
  start: '2024-11-01',
  methodology,
  breakdownMethodology,
}

export default adapter;