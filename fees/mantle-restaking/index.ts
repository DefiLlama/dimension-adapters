import * as sdk from "@defillama/sdk";
import { Adapter, FetchOptions, FetchResultV2 } from '../../adapters/types'
import { CHAIN } from '../../helpers/chains'
import { METRIC } from '../../helpers/metrics'

// docs: https://docs.mantle.xyz/meth/components/smart-contracts/restaking-cmeth
interface CmETHConfig {
  rewardsTreasury: string
  feeTreasury: string
  start: string
}

const cmETHConfig: Record<string, CmETHConfig> = {
  [CHAIN.ETHEREUM]: {
    rewardsTreasury: '0xfB7e8892fBDa0205f6BbdbCd90dD9b0bDD321D16', // MPTreasuryL1-Rewards
    feeTreasury: '0x7C67679b147DDDa9BB219EbaA58AA3ab1d846BfC', // For restaking fees
    start: '2024-11-19',
  },
}

// cmETH protocol takes 20%: https://docs.mantle.xyz/meth#cmeth
const PROTOCOL_FEE = 0.20 // 20%

async function fetch(options: FetchOptions): Promise<FetchResultV2> {
  const dailyFees = options.createBalances()
  const dailyRevenue = options.createBalances()
  const dailySupplySideRevenue = options.createBalances()

  const { rewardsTreasury, feeTreasury } = cmETHConfig[options.chain]

  // Track ETH received by Rewards Treasury
  let totalRewards = 0
  const rewardsTxs = await sdk.indexer.getTransactions({
    chain: options.chain,
    transactionType: 'to',
    addresses: [rewardsTreasury],
    from_block: Number(options.fromApi.block),
    to_block: Number(options.toApi.block),
  })

  if (rewardsTxs) {
    for (const tx of rewardsTxs) {
      totalRewards += Number(tx.value)
    }
  }

  // Track ETH received by Fee Treasury
  let protocolFees = 0
  const feeTxs = await sdk.indexer.getTransactions({
    chain: options.chain,
    transactionType: 'to',
    addresses: [feeTreasury],
    from_block: Number(options.fromApi.block),
    to_block: Number(options.toApi.block),
  })

  if (feeTxs) {
    for (const tx of feeTxs) {
      protocolFees += Number(tx.value)
    }
  }

  const totalFee = totalRewards + protocolFees

  // Calculate protocol revenue (20%) and supply side revenue (80%) from totalFee
  const protocolRevenue = totalFee * PROTOCOL_FEE
  const supplySideRevenue = totalFee * (1 - PROTOCOL_FEE)

  if (totalFee > 0) {
    dailyFees.addGasToken(supplySideRevenue, METRIC.STAKING_REWARDS)
    dailyFees.addGasToken(protocolRevenue, METRIC.PROTOCOL_FEES)
    dailyRevenue.addGasToken(protocolRevenue, METRIC.PROTOCOL_FEES)
    dailySupplySideRevenue.addGasToken(supplySideRevenue, METRIC.STAKING_REWARDS)
  }

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue: dailyRevenue,
    dailySupplySideRevenue,
  }
}

const adapter: Adapter = {
    version: 2,
    adapter: {
      [CHAIN.ETHEREUM]: {
        fetch,
        start: cmETHConfig[CHAIN.ETHEREUM].start,
      },
    },
    methodology: {
      Fees:
        "Total restaking yield generated by cmETH, split between protocol fees and rewards distributed to cmETH holders.",
      Revenue:
        "Protocol fees (20%) collected by Mantle from cmETH restaking rewards.",
      ProtocolRevenue:
        "Protocol fees collected by Mantle from cmETH restaking rewards.",
      SupplySideRevenue:
        "Restaking rewards distributed to cmETH holders after protocol fees.",
    },
    breakdownMethodology: {
      Fees: {
        [METRIC.STAKING_REWARDS]:
          "Restaking rewards distributed to cmETH holders from EigenLayer, Symbiotic, Karak and AVS services.",
        [METRIC.PROTOCOL_FEES]:
          "Protocol fees collected by Mantle from cmETH restaking rewards.",
      },
      Revenue: {
        [METRIC.PROTOCOL_FEES]:
          "Protocol fees collected by Mantle from cmETH restaking rewards.",
      },
      ProtocolRevenue: {
        [METRIC.PROTOCOL_FEES]:
          "Protocol fees collected by Mantle from cmETH restaking rewards.",
      },
      SupplySideRevenue: {
        [METRIC.STAKING_REWARDS]:
          "Restaking rewards distributed to cmETH holders after protocol fees.",
      },
    },
  };
  
  export default adapter;
