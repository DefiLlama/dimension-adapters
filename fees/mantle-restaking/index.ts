import { Adapter, FetchOptions, FetchResultV2 } from "../../adapters/types"
import { CHAIN } from "../../helpers/chains"
import { addGasTokensReceived } from "../../helpers/token"
import { METRIC } from "../../helpers/metrics"
import * as sdk from '@defillama/sdk'

const cmETH = '0xE6829d9a7eE3040e1276Fa75293Bde931859e8fA';
const accountant = '0x6049Bd892F14669a4466e46981ecEd75D610a2eC';
const stakingContract = '0xe3cBd06D7dadB3F4e6557bAb7EdD924CD1489E8f';
const pauserContract = '0x29Ab878aEd032e2e2c86FF4A9a9B05e3276cf1f8';

const BoringVaultAbis = {
  //vault
  totalSupply: 'uint256:totalSupply',
  // accountant
  base: 'address:base',
  // staking contract
  mETHToETH: 'function mETHToETH(uint256) view returns (uint256)',
  // pauser contract
  isStakingPaused: 'function isStakingPaused() view returns (bool)',
}

async function fetch(options: FetchOptions): Promise<FetchResultV2> {
  const dailyFees = options.createBalances()
  const dailySupplySideRevenue = options.createBalances()
  const dailyProtocolRevenue = options.createBalances()

  const token = await options.api.call({
    abi: BoringVaultAbis.base,
    target: accountant,
  })

  const decimals = 18
  const vaultRateBase = Number(10 ** Number(decimals))
  const oneEther = BigInt(10 ** 18)

  const startBlock = await options.getStartBlock()
  const endBlock = await options.getEndBlock()

  const isPaused = await sdk.api2.abi.call({
    abi: BoringVaultAbis.isStakingPaused,
    target: pauserContract,
    block: startBlock,
  })

  const balances = await addGasTokensReceived({
    options,
    multisigs: ['0x432ABcCb04DdD86Db9aA91FA3E03Fb566270c9ff'],
  })

  dailyFees.addBalances(balances, METRIC.MANAGEMENT_FEES)
  dailyProtocolRevenue.addBalances(balances, METRIC.MANAGEMENT_FEES);

  if (!isPaused) {
    // Get exchange rate at start of day
    const startRate = await sdk.api2.abi.call({
      abi: BoringVaultAbis.mETHToETH,
      target: stakingContract,
      params: [oneEther.toString()],
      block: startBlock,
    })

    // Get exchange rate at end of day
    const endRate = await sdk.api2.abi.call({
      abi: BoringVaultAbis.mETHToETH,
      target: stakingContract,
      params: [oneEther.toString()],
      block: endBlock,
    })

    const growthRate = Number(BigInt(endRate) - BigInt(startRate))

    const totalSupplyAtStart = await sdk.api2.abi.call({
      abi: BoringVaultAbis.totalSupply,
      target: cmETH,
      block: startBlock,
    })

    const totalDeposited = Number(totalSupplyAtStart) * Number(startRate) / vaultRateBase

    const supplySideYield = totalDeposited * growthRate / vaultRateBase

    dailyFees.add(token, supplySideYield, METRIC.ASSETS_YIELDS)
    dailySupplySideRevenue.add(token, supplySideYield, METRIC.ASSETS_YIELDS)
  }

  return {
    dailyFees,
    dailyRevenue: dailyProtocolRevenue,
    dailyProtocolRevenue,
    dailySupplySideRevenue,
  }
}


const methodology = {
  Fees: 'Total yields are generated by staking assets in DeFi strategies',
  SupplySideRevenue: 'The amount of yields distributed to cmETH stakers.',
  Revenue: 'Performance fees and platform fees distributed to Mantle Protocol.',
  ProtocolRevenue: 'Performance fees and platform fees distributed to Mantle Protocol.',
}

const breakdownMethodology = {
  Fees: {
    [METRIC.ASSETS_YIELDS]: 'Total yield generated by the vault strategy.',
    [METRIC.MANAGEMENT_FEES]: 'Platform fee portion collected by protocol.',
  },
  Revenue: {
    [METRIC.MANAGEMENT_FEES]: 'Platform fee portion collected by protocol.',
  },
  SupplySideRevenue: {
    [METRIC.ASSETS_YIELDS]: 'Yield portion distributed to cmETH stakers.',
  },
}

const adapter: Adapter = {
  version: 2,
  fetch,
  chains: [CHAIN.ETHEREUM],
  start: '2024-11-01',
  methodology,
  breakdownMethodology,
  allowNegativeValue: true,
}

export default adapter;
