import { CHAIN } from "../../helpers/chains";
import { FetchOptions, FetchResultV2, SimpleAdapter } from "../../adapters/types";
import { ChainApi } from "@defillama/sdk";

const methodology = {
    Fees: 'Management fees on yield generated by YieldFi',
    Revenue: 'Total yield generated by YieldFi across all supported chains',
    HoldersRevenue: 'Yield generated by vaults distributed to users',
}

// Contract addresses - Multi-chain configuration
const YUSD_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x19Ebd191f7A24ECE672ba13A302212b5eF7F35cb",
    [CHAIN.OPTIMISM]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.ARBITRUM]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.BASE]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.SONIC]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.PLUME]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.KATANA]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
    [CHAIN.BSC]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
    [CHAIN.AVAX]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
};

const VYUSD_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x2e3C5e514EEf46727DE1FE44618027A9b70D92FC",
    [CHAIN.OPTIMISM]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.ARBITRUM]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.BASE]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.SONIC]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.PLUME]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.KATANA]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
    [CHAIN.BSC]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
    [CHAIN.AVAX]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
};

const YETH_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x8464F6eCAe1EA58EC816C13f964030eAb8Ec123A",
};

const VYETH_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x3073112c2c4800b89764973d5790ccc7fba5c9f9",
};

const YBTC_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0xa01200b2e74DE6489cF56864E3d76BBc06fc6C43",
};

const VYBTC_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x1e2a5622178f93EFd4349E2eB3DbDF2761749e1B",
};

// API endpoints for APY data
const API_ENDPOINTS = {
    yUSD: 'https://ctrl.yield.fi/t/apy/yusd/apyHistory',
    vyUSD: 'https://ctrl.yield.fi/t/apy/vyusd/apyHistory',
    yETH: 'https://ctrl.yield.fi/t/apy/yeth/apyHistory',
    vyETH: 'https://ctrl.yield.fi/t/apy/vyeth/apyHistory',
    yBTC: 'https://ctrl.yield.fi/t/apy/ybtc/apyHistory',
    vyBTC: 'https://ctrl.yield.fi/t/apy/vybtc/apyHistory',
};

// ABIs
const ABIS = {
    totalSupply: 'function totalSupply() view returns (uint256)',
    pricePerShare: 'function pricePerShare() view returns (uint256)',
    decimals: 'function decimals() view returns (uint8)',
};

/**
 * Fetch latest APY data from the API
 */
const fetchLatestAPY = async (tokenSymbol: string): Promise<number> => {
    try {
        const endpoint = API_ENDPOINTS[tokenSymbol as keyof typeof API_ENDPOINTS];
        if (!endpoint) {
            console.error(`No API endpoint found for ${tokenSymbol}`);
            return 0;
        }

        const response = await fetch(endpoint);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const apyHistory = data.apy_history;

        if (!apyHistory || !Array.isArray(apyHistory) || apyHistory.length === 0) {
            console.error(`No APY history data found for ${tokenSymbol}`);
            return 0;
        }

        // Get the latest APY (first entry in the array is the most recent)
        const latestAPY = apyHistory[0].apy;
        return parseFloat(latestAPY.toFixed(2));
    } catch (error) {
        console.error(`Error fetching APY for ${tokenSymbol}:`, error);
        return 0;
    }
};

/**
 * Get TVL for a specific token on a specific chain
 */
const getTVL = async (api: ChainApi, tokenAddress: string): Promise<number> => {
    try {
        const response = await api.call({
            target: tokenAddress,
            abi: ABIS.totalSupply,
        });
        return parseFloat((Number(response) / 1e18).toFixed(2));
    } catch (error) {
        console.error(`Error getting TVL for ${tokenAddress}:`, error);
        return 0;
    }
};

/**
 * Calculate daily fees based on APY and TVL
 */
const calculateDailyYield = (apy: number, tvl: number): number => {
    if (apy === 0 || tvl === 0) return 0;
    const dailyRate = (apy/100)/365
    return tvl * dailyRate;
};

/**
 * Process token data for a specific chain
 */
const processToken = async (api: ChainApi, tokenAddress: string, symbol: string): Promise<number> => {
    try {
        const [tvl, apy] = await Promise.all([
            getTVL(api, tokenAddress),
            fetchLatestAPY(symbol)
        ]);

        if (apy === 0) {
            console.log(`No APY data available for ${symbol}`);
            return 0;
        }

        return calculateDailyYield(apy, tvl);
    } catch (error) {
        console.error(`Error processing ${symbol}:`, error);
        return 0;
    }
};

async function fetchFees(options: FetchOptions): Promise<FetchResultV2> {
    const dailyYield = options.createBalances();
    const chain = options.chain;
    const api = options.api;

    let totalDailyYield = 0;

    // Process yUSD and vyUSD for all chains
    const yusdAddress = YUSD_CONTRACTS[chain];
    const vyusdAddress = VYUSD_CONTRACTS[chain];

    if (yusdAddress) {
        const yusdYield = await processToken(api, yusdAddress, 'yUSD');
        totalDailyYield += yusdYield;
    }

    if (vyusdAddress) {
        const vyusdYield = await processToken(api, vyusdAddress, 'vyUSD');
        totalDailyYield += vyusdYield;
    }

    // Only process yETH, vyETH, yBTC, vyBTC on Ethereum
    if (chain === CHAIN.ETHEREUM) {
        const yethAddress = YETH_CONTRACTS[chain];
        const vyethAddress = VYETH_CONTRACTS[chain];
        const ybtcAddress = YBTC_CONTRACTS[chain];
        const vybtcAddress = VYBTC_CONTRACTS[chain];

        if (yethAddress) {
            const yethYield = await processToken(api, yethAddress, 'yETH');
            totalDailyYield += yethYield;
        }

        if (vyethAddress) {
            const vyethYield = await processToken(api, vyethAddress, 'vyETH');
            totalDailyYield += vyethYield;
        }

        if (ybtcAddress) {
            const ybtcYield = await processToken(api, ybtcAddress, 'yBTC');
            totalDailyYield += ybtcYield;
        }

        if (vybtcAddress) {
            const vybtcYield = await processToken(api, vybtcAddress, 'vyBTC');
            totalDailyYield += vybtcYield;
        }
    }

    // Add USD value to daily fees
    dailyYield.addUSDValue(totalDailyYield);

    // Calculate protocol fee (2%) and supply-side revenue (98%)
    const protocolFee = totalDailyYield * 0.02;
    const supplySideRevenue = totalDailyYield * 0.98;

    const dailyProtocolRevenue = options.createBalances();
    dailyProtocolRevenue.addUSDValue(protocolFee);
    dailyProtocolRevenue.addUSDValue(supplySideRevenue);

    const dailySupplySideRevenue = options.createBalances();
    dailySupplySideRevenue.addUSDValue(supplySideRevenue);
    return {
        dailyFees: protocolFee,
        dailyRevenue: dailyProtocolRevenue,
        dailyHoldersRevenue: dailySupplySideRevenue,
    };
}

const adapter: SimpleAdapter = {
    version: 2,
    methodology,
    adapter: {
        [CHAIN.ETHEREUM]: {
            fetch: fetchFees,
            start: '2024-11-11',
        },
        [CHAIN.OPTIMISM]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.ARBITRUM]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.BASE]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.SONIC]: {
            fetch: fetchFees,
            start: '2025-05-09',
        },
        [CHAIN.PLUME]: {
            fetch: fetchFees,
            start: '2025-06-10',
        },
        [CHAIN.KATANA]: {
            fetch: fetchFees,
            start: '2025-07-31',
        },
        [CHAIN.BSC]: {
            fetch: fetchFees,
            start: '2025-07-27',
        },
        [CHAIN.AVAX]: {
            fetch: fetchFees,
            start: '2025-07-31',
        },
    },
};

export default adapter;
