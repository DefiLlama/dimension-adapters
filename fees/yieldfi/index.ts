import { CHAIN } from "../../helpers/chains";
import { FetchOptions, FetchResultV2, SimpleAdapter } from "../../adapters/types";
import { ChainApi } from "@defillama/sdk";

const methodology = {
    Fees: 'Management fees on yield generated by YieldFi',
    Revenue: 'Total yield generated by YieldFi across all supported chains',
    HoldersRevenue: 'Yield generated by vaults distributed to users',
}

const feeOnTOkens = {
    'yUSD': 2.00,
    'vyUSD': 2.00,
    'yETH': 1.00,
    'vyETH': 1.00,
    'yBTC': 0.50,
    'vyBTC': 0.50,
}

// Contract addresses - Multi-chain configuration
const YUSD_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x19Ebd191f7A24ECE672ba13A302212b5eF7F35cb",
    [CHAIN.OPTIMISM]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.ARBITRUM]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.BASE]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.SONIC]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.PLUME]: '0x4772D2e014F9fC3a820C444e3313968e9a5C8121',
    [CHAIN.KATANA]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
    [CHAIN.BSC]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
    [CHAIN.AVAX]: "0x4772D2e014F9fC3a820C444e3313968e9a5C8121",
};

const VYUSD_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x2e3C5e514EEf46727DE1FE44618027A9b70D92FC",
    [CHAIN.OPTIMISM]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.ARBITRUM]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.BASE]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.SONIC]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.PLUME]: '0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de',
    [CHAIN.KATANA]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
    [CHAIN.BSC]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
    [CHAIN.AVAX]: "0xF4F447E6AFa04c9D11Ef0e2fC0d7f19C24Ee55de",
};

const YETH_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x8464F6eCAe1EA58EC816C13f964030eAb8Ec123A",
};

const VYETH_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x3073112c2c4800b89764973d5790ccc7fba5c9f9",
};

const YBTC_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0xa01200b2e74DE6489cF56864E3d76BBc06fc6C43",
};

const VYBTC_CONTRACTS = {
    [CHAIN.ETHEREUM]: "0x1e2a5622178f93EFd4349E2eB3DbDF2761749e1B",
};

// API endpoints for APY data
const API_ENDPOINTS = {
    yUSD: 'https://ctrl.yield.fi/t/apy/yusd/apyHistory',
    vyUSD: 'https://ctrl.yield.fi/t/apy/vyusd/apyHistory',
    yETH: 'https://ctrl.yield.fi/t/apy/yeth/apyHistory',
    vyETH: 'https://ctrl.yield.fi/t/apy/vyeth/apyHistory',
    yBTC: 'https://ctrl.yield.fi/t/apy/ybtc/apyHistory',
    vyBTC: 'https://ctrl.yield.fi/t/apy/vybtc/apyHistory',
};

// ABIs
const ABIS = {
    totalSupply: 'function totalSupply() view returns (uint256)',
    pricePerShare: 'function pricePerShare() view returns (uint256)',
    decimals: 'function decimals() view returns (uint8)',
};

/**
 * Fetch latest APY data from the API
 */
const fetchLatestAPY = async (tokenSymbol: string): Promise<number> => {
    try {
        const endpoint = API_ENDPOINTS[tokenSymbol as keyof typeof API_ENDPOINTS];
        if (!endpoint) {
            console.error(`No API endpoint found for ${tokenSymbol}`);
            return 0;
        }

        const response = await fetch(endpoint);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const apyHistory = data.apy_history;

        if (!apyHistory || !Array.isArray(apyHistory) || apyHistory.length === 0) {
            console.error(`No APY history data found for ${tokenSymbol}`);
            return 0;
        }

        // Get the latest APY (first entry in the array is the most recent)
        const latestAPY = apyHistory[0].apy;
        return parseFloat(latestAPY.toFixed(2));
    } catch (error) {
        console.error(`Error fetching APY for ${tokenSymbol}:`, error);
        return 0;
    }
};

/**
 * Get TVL for a specific token on a specific chain
 */
const getTVL = async (api: ChainApi, tokenAddress: string): Promise<number> => {
    try {
        const response = await api.call({
            target: tokenAddress,
            abi: ABIS.totalSupply,
        });
        return parseFloat((Number(response) / 1e18).toFixed(2));
    } catch (error) {
        console.error(`Error getting TVL for ${tokenAddress}:`, error);
        return 0;
    }
};

/**
 * Calculate daily fees based on APY and TVL
 */
const calculateDailyYield = (apy: number, tvl: number): number => {
    if (apy === 0 || tvl === 0) return 0;
    const dailyRate = apy/100/365
    return tvl * dailyRate;
};

const calculateDailyFees = (tvl: number, fee: number): number => {
    if (tvl === 0) return 0;
    const dailyRate = fee / 100;
    return (tvl * dailyRate)/365;
};

/**
 * Process token data for a specific chain
 */
const processToken = async (api: ChainApi, tokenAddress: string, symbol: string, fee: number): Promise<{yield: number, fees: number}> => {
    try {
        const [tvl, apy] = await Promise.all([
            getTVL(api, tokenAddress),
            fetchLatestAPY(symbol)
        ]);

        if (apy === 0) {
            console.log(`No APY data available for ${symbol}`);
            return {yield: 0, fees: 0};
        }

        return {yield: calculateDailyYield(apy, tvl), fees: calculateDailyFees(tvl, feeOnTOkens[symbol])};
    } catch (error) {
        console.error(`Error processing ${symbol}:`, error);
        return {yield: 0, fees: 0};
    }
};

async function fetchFees(options: FetchOptions): Promise<FetchResultV2> {
    const chain = options.chain;
    const api = options.api;
    let totalProtocolRevenue = 0;
    let totalSupplySideRevenue = 0;
    let totalFees = 0;

    // Process yUSD and vyUSD for all chains
    const yusdAddress = YUSD_CONTRACTS[chain];
    const vyusdAddress = VYUSD_CONTRACTS[chain];

    if (yusdAddress) {
        const {yield: yusdYield, fees: yusdFees} = await processToken(api, yusdAddress, 'yUSD', feeOnTOkens['yUSD']);
        totalFees += yusdFees;
        totalSupplySideRevenue += yusdYield;
    }

    if (vyusdAddress) {
        const {yield: vyusdYield, fees: vyusdFees} = await processToken(api, vyusdAddress, 'vyUSD', feeOnTOkens['vyUSD']);
        totalFees += vyusdFees;
        totalSupplySideRevenue += vyusdYield;
    }

    // Only process yETH, vyETH, yBTC, vyBTC on Ethereum
    if (chain === CHAIN.ETHEREUM) {
        const yethAddress = YETH_CONTRACTS[chain];
        const vyethAddress = VYETH_CONTRACTS[chain];
        const ybtcAddress = YBTC_CONTRACTS[chain];
        const vybtcAddress = VYBTC_CONTRACTS[chain];

        if (yethAddress) {
            const {yield: yethYield, fees: yethFees} = await processToken(api, yethAddress, 'yETH', feeOnTOkens['yETH']);
            totalFees += yethFees;
            totalSupplySideRevenue += yethYield;
        }

        if (vyethAddress) {
            const {yield: vyethYield, fees: vyethFees} = await processToken(api, vyethAddress, 'vyETH', feeOnTOkens['vyETH']);
            totalFees += vyethFees;
            totalSupplySideRevenue += vyethYield;
        }

        if (ybtcAddress) {
            const {yield: ybtcYield, fees: ybtcFees} = await processToken(api, ybtcAddress, 'yBTC', feeOnTOkens['yBTC']);
            totalFees += ybtcFees;
            totalSupplySideRevenue += ybtcYield;
        }

        if (vybtcAddress) {
            const {yield: vybtcYield, fees: vybtcFees} = await processToken(api, vybtcAddress, 'vyBTC', feeOnTOkens['vyBTC']);
            totalFees += vybtcFees;
            totalSupplySideRevenue += vybtcYield;
        }
    }

    return {
        dailyFees: totalFees,
        dailyRevenue: (totalFees + totalSupplySideRevenue),
        dailyHoldersRevenue: totalSupplySideRevenue,
    };
}

const adapter: SimpleAdapter = {
    version: 2,
    methodology,
    adapter: {
        [CHAIN.ETHEREUM]: {
            fetch: fetchFees,
            start: '2024-11-11',
        },
        [CHAIN.OPTIMISM]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.ARBITRUM]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.BASE]: {
            fetch: fetchFees,
            start: '2025-04-30',
        },
        [CHAIN.SONIC]: {
            fetch: fetchFees,
            start: '2025-05-09',
        },
        [CHAIN.PLUME]: {
            fetch: fetchFees,
            start: '2025-06-10',
        },
        [CHAIN.KATANA]: {
            fetch: fetchFees,
            start: '2025-07-31',
        },
        [CHAIN.BSC]: {
            fetch: fetchFees,
            start: '2025-07-27',
        },
        [CHAIN.AVAX]: {
            fetch: fetchFees,
            start: '2025-07-31',
        },
    },
};

export default adapter;
