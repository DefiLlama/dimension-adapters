import { SimpleAdapter, FetchOptions } from "../../adapters/types";
import { CHAIN } from "../../helpers/chains";

// Theo Straddle Vault addresses
const vaults: Record<string, string[]> = {
  [CHAIN.ETHEREUM]: [
    "0xd912325C960F1A6276F1E905d2f7715bD3d5C06d",
    "0x18e0C17bbbdf792925C2Af863570e0e6709DCdB0",
    "0x022D97090127eC95257B1cD844EBBfDCD57c50cE",
    "0xA3819f9a12CA6abeFcFd325B7d78207cdd4Bd9c3",
    "0x0B75e167F8A37179b7044414EE43e94cabeAA2FA",
  ],
  [CHAIN.ARBITRUM]: [
    "0xF37Fe9396Bb95f7823A29090c939847f1817bC8a",
    "0x4fE17dEFc597cC3bD6fBe16135d8Ac42D421907e",
    "0x3ca8F12D7B376E9Ef338d1C432CA1b51DD319009",
    "0x54602E5cBa09e01EeE9B2050F1F4f0Dc902CeE34",
  ],
  [CHAIN.BASE]: [
    "0x83C6aC60Cfb20a0dF00705A78263B88878EC19b4",
    "0xf677A02A91622E2a3ff5923c6530D383C29b0983",
    "0x0275A54EAD26a237803D8Cc6E0d63c954ad98bfE",
  ],
  [CHAIN.LINEA]: [
    "0xcF101e13b5181f79094B0726B03e89d1cB95b28C",
  ],
};

const ONE_18 = 10n ** 18n;

async function fetch(options: FetchOptions) {
  const dailyFees = options.createBalances();
  const dailySupplySideRevenue = options.createBalances();

  const chainVaults = vaults[options.chain] || [];

  const fromBlock = await options.getFromBlock();
  const toBlock = await options.getToBlock();

  const startPrices = await options.api.multiCall({
    abi: "function pricePerShare() view returns (uint256)",
    calls: chainVaults.map((v) => ({ target: v })),
    block: fromBlock,
    permitFailure: true,
  });

  const endPrices = await options.api.multiCall({
    abi: "function pricePerShare() view returns (uint256)",
    calls: chainVaults.map((v) => ({ target: v })),
    block: toBlock,
    permitFailure: true,
  });

  const vaultParams = await options.api.multiCall({
    abi: "function vaultParams() view returns (uint8, address, uint56, uint104)",
    calls: chainVaults.map((v) => ({ target: v })),
    permitFailure: true,
  });

  const endSupplies = await options.api.multiCall({
    abi: "uint256:totalSupply",
    calls: chainVaults.map((v) => ({ target: v })),
    block: toBlock,
    permitFailure: true,
  });

  for (let i = 0; i < chainVaults.length; i++) {
    const startPrice = startPrices[i];
    const endPrice = endPrices[i];
    const params = vaultParams[i];
    const endSupply = endSupplies[i];

    if (!startPrice || !endPrice || !params || !endSupply) {
      continue;
    }
    const [, asset] = params;

    // Calculate price appreciation and multiply by end supply to get yield in asset terms
    const priceAppreciation = BigInt(endPrice) - BigInt(startPrice);
    const tradingYield = (priceAppreciation * BigInt(endSupply)) / ONE_18;

    dailySupplySideRevenue.add(asset, tradingYield.toString());
    dailyFees.add(asset, tradingYield.toString());
  }

  return {
    dailyFees,
    dailySupplySideRevenue,
  };
}

const methodology = {
  Fees: "Trading PnL generated by Theo straddle vaults, PnL accrues to depositors.",
  SupplySideRevenue: "Vault depositor PnL as yield on deposited assets.",
};

const adapter: SimpleAdapter = {
  version: 2,
  fetch,
  adapter: {
    [CHAIN.ETHEREUM]: { start: '2023-12-01' },
    [CHAIN.ARBITRUM]: { start: '2023-12-01' },
    [CHAIN.BASE]: { start: '2024-03-18' },
    [CHAIN.LINEA]: { start: '2024-03-18' },
  },
  methodology,
  allowNegativeValue: true, // Straddle vaults can have losing days; ignoring losses would give inaccurate total fees
};

export default adapter;