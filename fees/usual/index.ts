import { FetchOptions, SimpleAdapter } from "../../adapters/types";
import { CHAIN } from "../../helpers/chains";

const treasury = '0xdd82875f0840aad58a455a70b88eed9f59cec7c7'
const USYS = '0x136471a34f6ef19fE571EFFC1CA711fdb8E49f2b'

const fetch = async ({getLogs, createBalances, fromApi, toApi, startTimestamp, endTimestamp}: FetchOptions) => {
    
    const tokenBalance = await fromApi.call({
        target: USYS,
        abi: "function balanceOf(address account) external view returns (uint256)",
        params: [treasury]
    })

    const latestRound = await toApi.call({
        target: "0x4c48bcb2160F8e0aDbf9D4F3B034f1e36d1f8b3e",
        abi: "function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)"
    })

    const lastRound = await toApi.call({
        target: "0x4c48bcb2160F8e0aDbf9D4F3B034f1e36d1f8b3e",
        abi: "function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)",
        params: [latestRound[0] - 1]
    }) 

    //check if updatedAt is between starttimestamp and endtimestamp, there will be only profit if report balance is called
    const latestUpdatedAt = latestRound[3]
    
    if (latestUpdatedAt < startTimestamp || latestUpdatedAt > endTimestamp) {
        return { }
    }

    const priceUSDLatest = latestRound[1] / 1e8
    const priceUSDLast = lastRound[1] / 1e8
    const priceUSD = priceUSDLatest - priceUSDLast

    const tokenBalanceUSD = tokenBalance / 1e6 * priceUSD 
    const dailyFees = createBalances()
    dailyFees.addUSDValue(tokenBalanceUSD)

  return {
    dailyFees,
    dailyRevenue: dailyFees,
  };
};

const adapter: SimpleAdapter = {
  version: 2,
  adapter: {
    [CHAIN.ETHEREUM]: {
        fetch: fetch,
        meta: {
            methodology: {
                dailyFees: "Interest generated by RWA collateral"
            }
        }
    }
  }
};

export default adapter;
