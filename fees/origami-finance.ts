import { FetchOptions, SimpleAdapter } from '../adapters/types';
import { CHAIN } from '../helpers/chains';

const config: Record<string, string[]> = {
  [CHAIN.ETHEREUM]: [
    '0x07c5500359161b81eb0dfff83097d5025d3cf5a2',
    '0x0f90a6962e86b5587b4c11ba2b9697dc3ba84800',
    '0xb50201998b92d2e685432b90331bb5825415926e',
  ],
};

const abis = {
  convertToAssets:
    'function convertToAssets(uint256 shares) view returns (uint256)',
  totalSupply: 'uint256:totalSupply',
  asset: 'address:asset',
};

const PERFORMANCE_FEE_BPS = 500n; // 5%
const BPS_DENOMINATOR = 10000n; // 10000bps = 100%
const ONE_SHARE = BigInt(1e18);

const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances();
  const dailyRevenue = options.createBalances();
  const dailyProtocolRevenue = options.createBalances();
  const dailySupplySideRevenue = options.createBalances();

  const vaults = config[options.chain];

  const [assets, totalSupplies, navBefore, navAfter] = await Promise.all([
    options.api.multiCall({
      abi: abis.asset,
      calls: vaults,
      permitFailure: true,
    }),
    options.toApi.multiCall({
      abi: abis.totalSupply,
      calls: vaults,
      permitFailure: true,
    }),
    options.fromApi.multiCall({
      abi: abis.convertToAssets,
      calls: vaults.map((v) => ({ target: v, params: [ONE_SHARE.toString()] })),
      permitFailure: true,
    }),
    options.toApi.multiCall({
      abi: abis.convertToAssets,
      calls: vaults.map((v) => ({ target: v, params: [ONE_SHARE.toString()] })),
      permitFailure: true,
    }),
  ]);

  for (let i = 0; i < vaults.length; i++) {
    const asset = assets[i];
    const supply = totalSupplies[i];
    const navStart = navBefore[i];
    const navEnd = navAfter[i];

    if (!asset || !supply || !navStart || !navEnd) {
      continue;
    }

    const navDelta = BigInt(navEnd) - BigInt(navStart);

    if (navDelta <= 0n) {
      continue;
    }

    const totalYield = (navDelta * BigInt(supply)) / ONE_SHARE;

    const performanceFee = (totalYield * PERFORMANCE_FEE_BPS) / BPS_DENOMINATOR;

    const supplySideYield = totalYield - performanceFee;

    // Fees represent total economic yield generated by the vaults (gross)
    dailyFees.add(asset, totalYield);

    dailyRevenue.add(asset, performanceFee);
    dailyProtocolRevenue.add(asset, performanceFee);
    dailySupplySideRevenue.add(asset, supplySideYield);
  }

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue,
    dailySupplySideRevenue,
  };
};

const methodology = {
  Fees: 'Total yield generated by vaults based on ERC4626 share value growth.',
  Revenue: '5% performance fee charged on positive vault yield.',
  ProtocolRevenue: 'Performance fees collected by the protocol.',
  SupplySideRevenue: 'Net vault yield accruing to depositors.',
};

const adapter: SimpleAdapter = {
  version: 2,
  adapter: {
    [CHAIN.ETHEREUM]: {
      fetch,
      start: '2024-10-17',
    },
  },
  methodology,
};

export default adapter;
