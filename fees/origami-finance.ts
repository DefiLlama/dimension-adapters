import { FetchOptions, SimpleAdapter } from '../adapters/types';
import { CHAIN } from '../helpers/chains';

// Origami ERC4626 vaults on Ethereum (primary source of protocol yield)
const VAULT_ADDRESSES: { [chain: string]: string[] } = {
  [CHAIN.ETHEREUM]: [
    '0x39Abb9D6487c5Fc17fC23BDAE2C5D01DeCD7f9db', // ovUSDC
    '0x44caae625f3C2C15c5c4B1e8C0429f54F6C1fD4e', // ovUSDT
    '0x824DCd7b044D60df2e89B1bB888e66D8BCf41491', // ovDAI
    '0x9e7Cd89aCC4Edc7f4C3F33876DF7BaaC7D76A0d2', // ovETH
  ],
};

const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances();
  const dailyRevenue = options.createBalances();
  const dailyProtocolRevenue = options.createBalances();
  const dailySupplySideRevenue = options.createBalances();

  const vaults = VAULT_ADDRESSES[options.chain];

  if (!vaults || vaults.length === 0) {
    throw new Error('No vaults found for chain ' + options.chain);
  }

  const [totalAssetsBefore, totalAssetsAfter, assetTokens] = await Promise.all([
    options.fromApi.multiCall({
      abi: 'uint256:totalAssets',
      calls: vaults,
      permitFailure: true,
    }),
    options.toApi.multiCall({
      abi: 'uint256:totalAssets',
      calls: vaults,
      permitFailure: true,
    }),
    options.api.multiCall({
      abi: 'address:asset',
      calls: vaults,
      permitFailure: true,
    }),
  ]);

  for (let i = 0; i < vaults.length; i++) {
    const assetBefore = totalAssetsBefore[i];
    const assetAfter = totalAssetsAfter[i];
    const assetToken = assetTokens[i];

    if (!assetBefore || !assetAfter || !assetToken) {
      continue;
    }

    // NOTE: totalAssets may include deposits/withdrawals (positive deltas are treated as yield)
    const yieldAmount = BigInt(assetAfter) - BigInt(assetBefore);

    if (yieldAmount <= 0n) {
      continue;
    }

    dailyFees.add(assetToken, yieldAmount);

    const protocolFee = (yieldAmount * 5n) / 100n; // 5% performance fee assumption
    dailyProtocolRevenue.add(assetToken, protocolFee);
    dailyRevenue.add(assetToken, protocolFee);

    const supplySideFee = yieldAmount - protocolFee;
    dailySupplySideRevenue.add(assetToken, supplySideFee);
  }

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue,
    dailySupplySideRevenue,
  };
};

const methodology = {
  Fees: 'Total yield generated by Origami ERC4626 vaults, measured as the daily change in totalAssets before fee distribution.',
  Revenue:
    'Protocol performance fees taken as a percentage of vault yield and collected via share inflation.',
  ProtocolRevenue:
    'Performance fees minted as new vault shares to the protocol treasury.',
  SupplySideRevenue:
    'Remaining vault yield (after performance fees) that accrues to existing vault shareholders. This represents the net return earned by depositors.',
  Limitations:
    'Uses a fixed 5% performance fee assumption (actual fees vary by vault), relies on a hard-coded ERC4626 vault list, excludes deposit/exit fees (which accrue to vault holders), and ignores days with zero or negative net yield.',
};

const adapter: SimpleAdapter = {
  version: 2,
  adapter: {
    [CHAIN.ETHEREUM]: {
      fetch,
      start: '2024-04-02',
    },
  },
  methodology,
};

export default adapter;
