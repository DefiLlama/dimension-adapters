import { FetchOptions, SimpleAdapter } from '../../adapters/types';
import { CHAIN } from '../../helpers/chains';

const ACCOUNTING = '0xa436c5Dd1Ba62c55D112C10cd10E988bb3355102';
const USDE = '0x4c9EDD5852cd905f086C759E8383e09bff1E68B3';
const CDO = '0x908B3921aaE4fC17191D382BB61020f2Ee6C0e20';
const JRT = '0xC58D044404d8B14e953C115E67823784dEA53d8F';
const SRT = '0x3d7d6fdf07EE548B939A80edbc9B2256d0cdc003';
const STRATEGY = '0xdbf4FB6C310C1C85D0b41B5DbCA06096F2E7099F';
const WAD = 1e18;

// Events
const FEE_ACCRUED_EVENT = "event FeeAccrued(bool isJrt, uint256 amountToReserve, uint256 amountToTranche)";
const RESERVE_REDUCED_EVENT = "event ReserveReduced(address token, uint256 amount)";
const DEPOSIT_EVENT = "event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares)";
const WITHDRAW_EVENT = "event Withdraw(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares)";

const fetch = async (options: FetchOptions) => {
  const dailyFees = options.createBalances();
  const dailyRevenue = options.createBalances();
  const dailyProtocolRevenue = options.createBalances();
  const dailySupplySideRevenue = options.createBalances();

  let redemptionFeesTotal = 0;
  let redemptionFeesReserve = 0;
  let totalDeposits = 0;
  let totalWithdrawals = 0;

  // 1. Get NAV (TVL) and ReserveBps
  // NAV here represents the Total Value Locked (Strategy Assets)
  const [navStart, navEnd, reserveBps] = await Promise.all([
    options.fromApi.call({ target: ACCOUNTING, abi: "function nav() view returns (uint256)" }),
    options.toApi.call({ target: ACCOUNTING, abi: "function nav() view returns (uint256)" }),
    options.api.call({ target: ACCOUNTING, abi: "function reserveBps() view returns (uint256)" }),
  ]);

  // 2. Get User Flows (Deposits/Withdrawals) to calculate Net Flows
  // Yield = deltaTVL - NetFlows
  const vaultAddresses = [JRT, SRT];

  const [depositLogs, withdrawLogs] = await Promise.all([
    options.getLogs({ targets: vaultAddresses, eventAbi: DEPOSIT_EVENT }),
    options.getLogs({ targets: vaultAddresses, eventAbi: WITHDRAW_EVENT }),
  ]);

  for (const log of depositLogs) {
    totalDeposits += Number(log.assets);
  }
  for (const log of withdrawLogs) {
    totalWithdrawals += Number(log.assets);
  }
  const netUserFlows = totalDeposits - totalWithdrawals;

  // 3. Get Admin Flows (Reserve Reductions)
  // This reduces NAV/TVL but is not a yield loss (it's moving funds to treasury).
  // We must ADD it back to calculate the organic yield generated by the strategy.
  const reserveLogs = await options.getLogs({
    target: CDO,
    eventAbi: RESERVE_REDUCED_EVENT,
  });

  const totalReserveReductions = options.createBalances();

  for (const log of reserveLogs) {
    totalReserveReductions.add(log.token, log.amount);
  }

  // 4. Calculate Gross Underlying Yield
  // Yield Formula: (EndTVL - StartTVL) - (Deposits - Withdrawals) + (AdminReductions)
  const deltaNav = Number(navEnd) - Number(navStart);
  const totalReserveReductionsUSD = await totalReserveReductions.getUSDValue();
  const grossYield = deltaNav - netUserFlows + (totalReserveReductionsUSD * WAD);

  // 5. Calculate Fees/Revenue Components
  // Performance Fee = GrossYield * reserveBps
  // reserveBps is 1e18 based (0.05e18 = 5%)
  const performanceFee = grossYield > 0 ? (grossYield * reserveBps) / WAD : 0;

  // Redemption Fees (tracked via FeeAccrued events)
  const feeLogs = await options.getLogs({
    target: ACCOUNTING,
    eventAbi: FEE_ACCRUED_EVENT,
  });

  feeLogs.forEach((log: any) => {
    const toReserve = Number(log.amountToReserve);
    const toTranche = Number(log.amountToTranche);
    redemptionFeesTotal += toReserve + toTranche;
    redemptionFeesReserve += toReserve;
  });

  const redemptionFeesTranche = redemptionFeesTotal - redemptionFeesReserve;

  // 6. Aggregate Metrics

  // Fees: Gross Yield  + All Redemption Fees
  const totalFees = grossYield + redemptionFeesTotal;

  // Protocol Revenue: Performance Fee + Redemption Fees Reserve
  const protocolRevenue = performanceFee + redemptionFeesReserve;

  // Total Revenue: Performance Fee + Redemption Fees Reserve
  const totalRevenue = performanceFee + redemptionFeesReserve;

  // SupplySide Revenue: Gross Yield - 2*Performance Fees + Redemption Fees kept by Tranche
  const supplySideRevenue = grossYield - performanceFee + redemptionFeesTranche;

  dailyFees.add(USDE, totalFees);
  dailyRevenue.add(USDE, totalRevenue);
  dailyProtocolRevenue.add(USDE, protocolRevenue);
  dailySupplySideRevenue.add(USDE, supplySideRevenue);

  return {
    dailyFees,
    dailyRevenue,
    dailyProtocolRevenue,
    dailySupplySideRevenue,
  };
};

const methodology = {
  Fees: "Includes yield generated on deposited assets and redemption fees charged by Strata.",
  Revenue: "Protocol revenue consists of performance fees (5-10%) charged by Strata on the yield generated and redemption fees paid by the users. ",
  ProtocolRevenue: "Protocol revenue consists of performance and redemption fees collected by Strata, including the portion of fees shared with reserve.",
  SupplySideRevenue: "Net yield distributed to tranches (after performance fees) plus the portion of redemption fees that remain in the tranche."
}

const adapter: SimpleAdapter = {
  version: 2,
  pullHourly: true,
  fetch,
  chains: [CHAIN.ETHEREUM],
  start: '2025-10-05',
  methodology,
  allowNegativeValue: true,
}

export default adapter;
